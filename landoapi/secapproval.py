# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this
# file, You can obtain one at http://mozilla.org/MPL/2.0/.
"""Functions related to the Security Bug Approval Process.

See https://wiki.mozilla.org/Security/Bug_Approval_Process.
"""
from sqlalchemy.dialects.postgresql import insert

from landoapi.models.secapproval import SecApprovalRequestEvent, SecApprovalRevision
from landoapi.phabricator import PhabricatorClient
from landoapi.projects import get_sec_approval_project_phid
from landoapi.storage import db

# Template for submitting a sec-approval comment to Phabricator. The message is
# written in first-person form because it is being authored by the user in Lando and
# posted under their username.
#
# The message is formatted as Remarkup.
# See https://phabricator.services.mozilla.com/book/phabricator/article/remarkup/
SECURE_COMMENT_TEMPLATE = """
I have written a sanitized comment message for this revision. It should
follow the [Security Bug Approval
Guidelines](https://wiki.mozilla.org/Security/Bug_Approval_Process).

Could a member of the `sec-approval` team please review this message?
If the message is suitable for landing in mozilla-central please mark
this code review as `Accepted`.

```
{message}
```
"""


def send_sanitized_commit_message_for_review(revision_phid, message, phabclient):
    """Send a sanitized commit message for review by the sec-approval team.

    See https://wiki.mozilla.org/Security/Bug_Approval_Process.

    Args:
        revision_phid: The PHID of the revision to edit.
        message: The sanitized commit message string we want to be reviewed.
        phabclient: A PhabClient instance.

    Returns:
        A list of Phabricator transactions that were generated by the
        sec-approval request.
    """
    comment = SECURE_COMMENT_TEMPLATE.format(message=message)
    sec_approval_phid = get_sec_approval_project_phid(phabclient)
    response = phabclient.call_conduit(
        "differential.revision.edit",
        objectIdentifier=revision_phid,
        transactions=[
            # The caller's alternative commit message is published as a comment.
            {"type": "comment", "value": comment},
            # We must get one of the sec-approval project members to approve the
            # alternate commit message for the review to proceed.
            #
            # We need to handle the case where the sec-approval team has approved a
            # previous alternate commit message and the author has sent a new
            # message. In this case we want the review to block on the sec-approval
            # team again and for the sec-approval team to review the new message.
            # Explicitly re-adding the sec-approval team to the review will clear any
            # previous reviews the team did and change their state to "blocking,
            # needs review".  Other reviewers' reviews will be left untouched. The
            # overall state of the revision will become "Needs Review".
            #
            # NOTE: the 'blocking(PHID)' syntax is undocumented at the time of
            # writing.
            {"type": "reviewers.add", "value": [f"blocking({sec_approval_phid})"]},
        ],
    )
    return PhabricatorClient.expect(response, "transactions")


def save_sec_approval_request_event(revision_phid, transactions):
    """Save information about a sec-approval review request to the database.

    Args:
        revision_phid: The PHID of the revision that we requested sec-approval on.
        transactions: A list Phabricator transaction data results related to the
            sec-approval event that we want to save.

    Returns:
        The `SecApprovalRequestEvent` that was saved to the database.
    """
    possible_comment_phids = []
    for transaction in transactions:
        phid = PhabricatorClient.expect(transaction, "phid")
        possible_comment_phids.append(phid)

    # Add the revision PHID to the database.  Use an upsert to avoid a race condition
    # between two threads adding a new revision PHID to the table.  Collisions on
    # insert due to the race should happen rarely.  Re-inserting an existing ID
    # should happen infrequently when we add a second or third sec-approval
    # request to a revision.
    insert_stmt = insert(SecApprovalRevision).values(phid=revision_phid)
    insert_stmt = insert_stmt.on_conflict_do_nothing(index_elements=["phid"])
    db.session.execute(insert_stmt)

    revision = SecApprovalRevision.query.filter_by(phid=revision_phid).one()

    event = SecApprovalRequestEvent(
        revision=revision, comment_candidates=possible_comment_phids
    )
    db.session.add(event)
    db.session.commit()
    return event
